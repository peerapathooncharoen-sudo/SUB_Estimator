<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>การประมาณราคาค่าแรง SUB</title>

  <!-- [ADD] small inline SVG favicon to prevent external 404 -->
  <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='100%' height='100%' fill='%231976d2'/><text x='50%' y='50%' fill='white' font-size='10' font-family='Arial' dominant-baseline='middle' text-anchor='middle'>S</text></svg>">

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }
    h1, h2 {
      text-align: center;
    }
    .section {
      background: white;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .info-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    label {
      font-weight: bold;
    }
    input {
      width: 100%;
      padding: 5px;
      margin-top: 5px;
      box-sizing: border-box;
    }

   /* single table reset (keep only one) */
   table {
     width: 100%;
     border-collapse: collapse;
     margin-top: 10px;
   }

   /* items-table: make Power & Control tables use fixed layout with consistent column widths */
   .items-table {
     width: 100%;
     border-collapse: collapse;
     margin-top: 10px;
     table-layout: fixed; /* important for equal column behavior */
   }
   /* column width distribution (No, Qty, Price, Description, Total) */
   .items-table col:nth-child(1){ width:10%; }
   .items-table col:nth-child(2){ width:10%; }
   .items-table col:nth-child(3){ width:15%; }
   .items-table col:nth-child(4){ width:55%; }
   .items-table col:nth-child(5){ width:10%; }
   /* overflow handling so long text in Description truncates with ellipsis */
   .items-table col:nth-child(6){ width:8%; }
   .items-table td:last-child { white-space:nowrap; text-align:center; }
   .items-table button {
    box-sizing: border-box;
    padding: 4px 8px;
    border: 1px solid #bdbdbd;
    background: #fff;
    cursor: pointer;
    border-radius: 4px;
   }
   .items-table th, .items-table td {
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
   }
   th, td {
     border: 0.9px solid #ccc;
     padding: 8px;
     text-align: center;
   }
   th {
     background-color: #f2f2f2;
   }
   .total {
     font-weight: bold;
     text-align: right;
     margin-top: 10px;
   }
   button {
     margin-top: 10px;
   }
   pre {
     white-space: pre-wrap;
     word-wrap: break-word;
   }
   /* saved-output acts as the stage for PDF preview; center its child both horizontally and vertically */
   #saved-output {
     line-height: 1.8;
     font-size: 16px;
     color: #111;
     display: flex;
     align-items: center;      /* vertical centering */
     justify-content: center;  /* horizontal centering */
     min-height: 320px;        /* keeps a reasonable preview area */
     padding: 12px;            /* small stage padding */
     box-sizing: border-box;
   }

   /* inner stage that holds the white pdf-page; allows vertical centering when page is shorter than stage */
   #saved-output .pdf-stage { display:flex; align-items:center; justify-content:center; width:100%; }
   /* headings inside saved output */
   #saved-output h2,
   #saved-output h3 {
     margin: 18px 0 14px;
   }
   /* make the info blocks (SUB / summary) more spaced */
   #saved-output > div > div,
   #saved-output .summary-row,
   #saved-output .info-row {
     margin-bottom: 14px;
   }
   /* tables inside saved output */
   #saved-output .items-table {
     margin-top: 12px;
   }
   #saved-output .items-table th,
   #saved-output .items-table td {
     padding: 10px 12px;
   }
   /* signature table spacing */
   #saved-output table[style*="border:1px solid #000"] {
     margin-top: 20px;
   }
   #saved-output .generated {
     margin-top: 14px;
     font-size: 14px;
     color: #666;
   }
  #saved-output .pdf-page {
    /* keep pdf-page auto-sizing but remove all internal padding so content is flush to edges */
    display: inline-block;
    width: auto;
    height: auto;
    max-width: 100%;
    margin: 0;
    padding: 0; /* completely flush left/right/top/bottom */
    background: #ffffff;
    color: #111;
    box-shadow: none;
    font-size: 11px;
    line-height: 1.25;
  }

  /* helper class applied only during PDF export to force single-line behavior */
  .pdf-nowrap * {
    white-space: nowrap !important;
    overflow: visible !important;
    text-overflow: clip !important;
  }

  /* stronger selector for when pdf-page element itself has the class - also add a visible outline during debug */
  .pdf-page.pdf-nowrap,
  .pdf-page.pdf-nowrap * {
    white-space: nowrap !important;
    overflow: visible !important;
    text-overflow: clip !important;
  }
  /* debug outline to visually show when the class is active (removed after capture) */
  .pdf-page.pdf-nowrap { outline: 3px dashed rgba(200,0,0,0.9); }

  /* tighten table spacing inside pdf-page */
  #saved-output .pdf-page .items-table th,
  #saved-output .pdf-page .items-table td {
    padding: 4px 6px;        /* reduced padding */
    font-size: 10.5px;
  }

  /* reduce signature box height and padding */
  #saved-output .pdf-page .sig-table td {
    padding: 8px;
    vertical-align: top;
    height: 56px;
  }

  /* tighter headings */
  #saved-output .pdf-page h2 { margin: 4px 0 8px; font-size: 15px; }
  #saved-output .pdf-page h3 { margin: 6px 0 6px; font-size: 12px; }

  /* reduce saved-output container padding on page */
  #saved-output { padding: 0px; background: transparent; }

  /* --- Removed complex A4 / rotate CSS and replaced with minimal preview styles --- */
  /* Keep a simple, non-rotated preview container so saved-output shows placeholder from LocalStorage.js */
  #saved-output {
    display:flex;
    align-items:center;
    justify-content:center;
    background: transparent;
    padding: 0px;
    min-height: 320px;
    box-sizing: border-box;
    overflow: visible;
  }
  #saved-output .pdf-stage { width:100%; display:flex; justify-content:center; }
  #saved-output .pdf-page {
    /* lightweight A4-like bounds for preview only (no rotation) */
    width: 297mm;
    min-height: 210mm;
    height: auto;
    overflow: visible;
    box-sizing: border-box;
    background: #ffffff;
    padding: 0; /* flush to edges */
    color: #111;
    font-family: "Tahoma","Arial","Helvetica",sans-serif;
    font-size: 11px;
    line-height: 1.15;
    display:block;
    margin:0 auto;
  }

  /* Note: rotation helpers (.pdf-rotate-wrapper, .pdf-page.pdf-rotate-90) intentionally removed.
     When you provide the new layout HTML/CSS I will insert exact styles. */
  </style>

  <!-- [ADD] Shim: map 'unload' listeners to 'pagehide' (+ 'visibilitychange') to avoid deprecation warning -->
  <script>
    (function () {
      const origAdd = EventTarget.prototype.addEventListener;
      const origRemove = EventTarget.prototype.removeEventListener;
      const map = new WeakMap();

      function attachMapped(target, listener, options) {
        const onPageHide = function (ev) { try { listener.call(this, ev); } catch (_) {} };
        const onVisChange = function (ev) {
          try { if (document.visibilityState === 'hidden') listener.call(document, ev); } catch (_) {}
        };
        origAdd.call(target, 'pagehide', onPageHide, options);
        if (target !== document) origAdd.call(document, 'visibilitychange', onVisChange, options);
        map.set(listener, { onPageHide, onVisChange, target });
      }

      EventTarget.prototype.addEventListener = function (type, listener, options) {
        if (type === 'unload' && typeof listener === 'function') {
          console.info('[unload->pagehide shim] addEventListener detected\nstack:\n' + (new Error().stack || ''));
          attachMapped(this, listener, options);
          return;
        }
        return origAdd.call(this, type, listener, options);
      };

      EventTarget.prototype.removeEventListener = function (type, listener, options) {
        if (type === 'unload' && map.has(listener)) {
          const { onPageHide, onVisChange, target } = map.get(listener);
          try { origRemove.call(target, 'pagehide', onPageHide, options); } catch(_) {}
          try { if (target !== document) origRemove.call(document, 'visibilitychange', onVisChange, options); } catch(_) {}
          map.delete(listener);
          return;
        }
        return origRemove.call(this, type, listener, options);
      };

      function hookOnUnload(obj, label) {
        const storeKey = Symbol(label + '.onunload');
        Object.defineProperty(obj, 'onunload', {
          configurable: true,
          enumerable: true,
          get() { return obj[storeKey] || null; },
          set(fn) {
            // remove previous mapped handler
            const prev = obj[storeKey];
            if (prev && map.has(prev)) {
              const { onPageHide, onVisChange, target } = map.get(prev);
              try { origRemove.call(target, 'pagehide', onPageHide); } catch(_) {}
              try { if (target !== document) origRemove.call(document, 'visibilitychange', onVisChange); } catch(_) {}
              map.delete(prev);
            }
            if (typeof fn === 'function') {
              console.info('[unload->pagehide shim] ' + label + '.onunload assignment detected\nstack:\n' + (new Error().stack || ''));
              obj[storeKey] = fn;
              attachMapped(obj, fn);
            } else {
              obj[storeKey] = null;
            }
          }
        });
      }

      hookOnUnload(window, 'window');
      hookOnUnload(document, 'document');
    })();
  </script>

  <!-- DB loader: ใส่กลับมาให้โหลด DatabasePW.js/DatabaseCT.js -->
  <script>
    // เตรียมตัวแปร (กันกรณียังไม่ถูกประกาศ)
    window.powerDatabase = window.powerDatabase || {};
    window.controlDatabase = window.controlDatabase || {};
  </script>
  <script>
    (function () {
      const files = ['DatabasePW.js', 'DatabaseCT.js'];

      async function loadSequential(buster) {
        for (const f of files) {
          await new Promise((resolve) => {
            const s = document.createElement('script');
            s.src = f + '?v=' + encodeURIComponent(buster);
            s.onload = resolve;
            s.onerror = resolve;
            document.head.appendChild(s);
          });
        }
        try { document.dispatchEvent(new Event('db-scripts-loaded')); } catch (e) {}
        try { localStorage.removeItem('dbVersionHint'); } catch (e) {}
      }

      (async function chooseBuster() {
        const origin = location.origin;
        const basePath = location.pathname.replace(/\/[^\/]*$/, '/');
        const hint = (function(){ try { return localStorage.getItem('dbVersionHint') || ''; } catch(e){ return ''; } })();

        // fallback
        loadSequential(String(Date.now()) + (hint ? '-' + hint : ''));
      })();
    })(); 
  </script>
  
  <script>
    // ถ้าแท็บอื่นบันทึก DB ให้รีโหลดเพื่อดึงเวอร์ชันล่าสุด
    window.addEventListener('storage', function (e) {
      if (e && e.key === 'dbVersionHint' && e.newValue) {
        try { localStorage.removeItem('dbVersionHint'); } catch(_) {}
        location.reload();
      }
    }); 
  </script>
  <script>
    // เพิ่ม normalization ให้รองรับทั้งชื่อ powerDatabase/controlDatabase และ databasePW/databaseCT
    function normalizeDbGlobals() {
      try {
        // Power
        if (window.databasePW && !window.powerDatabase) window.powerDatabase = window.databasePW;
        if (window.powerDatabase && !window.databasePW) window.databasePW = window.powerDatabase;
        // Control
        if (window.databaseCT && !window.controlDatabase) window.controlDatabase = window.databaseCT;
        if (window.controlDatabase && !window.databaseCT) window.databaseCT = window.controlDatabase;
      } catch (e) { console.warn('normalizeDbGlobals failed', e); }
    }

    // เรียก normalize ทันทีหลังโหลดสคริปต์ DB สำเร็จ
    document.addEventListener('db-scripts-loaded', () => {
      normalizeDbGlobals();
    });
  </script>
</head>
<body>
  
  <!-- โหลด auth ก่อนสคริปต์หลัก เพื่อให้ตรวจสิทธิ์ก่อนทำงาน -->
  <script src="Auth.js"></script>

  <!-- header logout -->
  <div id="auth-header" style="padding:10px;display:flex;justify-content:flex-end;gap:8px;">
    <span id="auth-welcome" style="font-size:13px;"></span>
    <button id="btn-logout" type="button">Logout</button>
  </div>

  <!-- Onboarding modal: shown only when no users exist -->
  <div id="onboard-modal" aria-hidden="true" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);align-items:center;justify-content:center;z-index:9999">
    <div style="background:#fff;padding:18px;border-radius:8px;max-width:420px;width:100%;box-shadow:0 6px 24px rgba(0,0,0,.3)">
      <h2 style="margin-top:0">Create initial user</h2>
      <p style="color:#444;font-size:13px">No users found. Create the first account to use the app.</p>
      <div style="display:flex;flex-direction:column;gap:8px;margin-top:12px">
        <input id="onboard-username" placeholder="Username" style="padding:8px;border:1px solid #ccc;border-radius:4px">
        <input id="onboard-password" type="password" placeholder="Password" style="padding:8px;border:1px solid #ccc;border-radius:4px">
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="onboard-create" type="button">Create account</button>
        </div>
        <div id="onboard-msg" style="color:#c00;font-size:13px;min-height:18px"></div>
      </div>
    </div>
  </div>

<script>
  // ensure DOM ready then init auth UI and listener
  document.addEventListener('DOMContentLoaded', function () {
    // redirect to login if not authenticated
      // If Auth is present, check for existing users. If none, show onboarding UI.
      if (window.getUsers && window.getUsers().length === 0) {
        // show onboarding modal
        const modal = document.getElementById('onboard-modal');
        if (modal) modal.style.display = 'flex';
        const btnCreate = document.getElementById('onboard-create');
        const userIn = document.getElementById('onboard-username');
        const passIn = document.getElementById('onboard-password');
        const msg = document.getElementById('onboard-msg');
        if (btnCreate) btnCreate.addEventListener('click', async () => {
          const u = userIn.value && userIn.value.trim();
          const p = passIn.value && passIn.value.trim();
          msg.textContent = '';
          if (!u || !p) { msg.textContent = 'Username and password required'; return; }
          try {
            const res = await registerUser(u, p);
            if (!res || !res.success) { msg.textContent = res && res.error ? res.error : 'Failed to create user'; return; }
            setSession && setSession(u);
            modal.style.display = 'none';
            // reload to initialize UI with session
            location.reload();
          } catch (e) {
            msg.textContent = 'Error creating user';
            console.error(e);
          }
        });
        return; // stop further init until user created
      }
    
      // If session exists, show welcome and logout button as before
      if (!window.ensureAuth || !window.ensureAuth()) return;
    
      const s = window.getSession && window.getSession();
      const welcome = document.getElementById('auth-welcome');
      if (welcome && s && s.username) welcome.textContent = 'ผู้ใช้: ' + s.username;
    
      const btn = document.getElementById('btn-logout');
      if (btn) {
        btn.addEventListener('click', function () {
          // remove session and go to login
          window.clearSession && window.clearSession();
          setTimeout(() => location.href = 'login.html', 50);
        });
      }
  });
</script>

  <div class="title-wrap">
    <div class="title-row">
      <h1>การประมาณราคาค่าแรง SUB</h1>
      <a href="Edit_database.html" class="btn-edit-db" title="แก้ไข Database">แก้ไข Database</a>
    </div>
  </div>

  <!-- Quick Add: เพิ่ม/แก้รายการเข้า Database โดยตรง -->
  <!--
  <div class="section">
    <h2>เพิ่มข้อมูลเข้า Database (Quick Add)</h2>
    <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:flex-end">
      <div>
        <label for="qa-type" style="font-weight:bold">ประเภท</label>
        <select id="qa-type" style="padding:6px">
          <option value="pw">Power</option>
          <option value="ct">Control</option>
        </select>
      </div>
      <div>
        <label for="qa-no" style="font-weight:bold">No</label>
        <input id="qa-no" type="number" min="0" placeholder="เช่น 1001" oninput="idxPrefillFromDb()" style="min-width:120px">
      </div>
      <div>
        <label for="qa-price" style="font-weight:bold">Price</label>
        <input id="qa-price" type="number" min="0" step="0.01" placeholder="0.00" style="min-width:140px">
      </div>
      <div style="flex:1;min-width:260px">
        <label for="qa-desc" style="font-weight:bold">Description</label>
        <input id="qa-desc" type="text" placeholder="รายละเอียด...">
      </div>
      <div>
        <button type="button" onclick="idxSaveDbItem()">บันทึกเข้า Database</button>
      </div>
    </div>
    <div id="idx-db-msg" style="font-size:13px;margin-top:6px;color:#444"></div>
  </div>
  -->

  <!-- add html2canvas (required for reliable capture) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <!-- add jsPDF UMD so window.jspdf.jsPDF is available -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="LocalStorage.js"></script>

  <!-- เปลี่ยนกลับเป็น section ปกติ และลบปุ่มเดิมในกล่องแรก -->
  <div class="section">
    <div class="info-grid">
      <!-- removed old inline button
      <div style="grid-column: 1 / -1; display:flex; justify-content:flex-end; margin-bottom:4px">
        <a href="Edit_database.html"><button type="button">แก้ไข Database</button></a>
      </div>
      -->
      <div><label>SUB Name:</label><input type="text" id="subName" name="subName"></div>
      <div><label>WA:</label><input type="text" id="wa" name="wa"></div>
      <div><label>Project:</label><input type="text" id="project" name="project"></div>
      <div><label>Cubicle:</label><input type="text" id="cubicle" name="cubicle"></div>
      <div><label>Serial:</label><input type="text" id="serial" name="serial"></div>
    </div>
  </div>

<!-- Power & Control side-by-side (responsive) -->
<div class="section">
  <div class="pc-row" style="display:flex;gap:12px;flex-wrap:wrap">
    <div class="pc-col" style="flex:1;min-width:360px">
      <div class="pc-inner section">
        <h2>Power</h2>
        <button onclick="addRow('power')">เพิ่มแถว</button>
        <table class="items-table">
          <colgroup><col><col><col><col><col><col></colgroup>
          <thead>
            <tr><th>No</th><th>Qty</th><th>Price</th><th>Description</th><th>Total</th><th>ลบ</th></tr>
          </thead>
          <tbody id="power-table-body"></tbody>
        </table>
        <div id="power-price" class="total">Power Price: 0.00 Baht</div>
      </div>
    </div>

    <div class="pc-col" style="flex:1;min-width:360px">
      <div class="pc-inner section">
        <h2>Control</h2>
        <button onclick="addRow('control')">เพิ่มแถว</button>
        <table class="items-table">
          <colgroup><col><col><col><col><col><col></colgroup>
          <thead>
            <tr><th>No</th><th>Qty</th><th>Price</th><th>Description</th><th>Total</th><th>ลบ</th></tr>
          </thead>
          <tbody id="control-table-body"></tbody>
        </table>
        <div id="control-price" class="total">Control Price: 0.00 Baht</div>
      </div>
    </div>
  </div>
</div>

  <div class="section">
    <div class="info-grid">
      <div><label>จำนวนชุด (Set):</label><input type="number" id="total-set" value="1" onchange="updateSummary()"></div>
      <div><label>ราคาต่อชุด:</label><input type="text" id="unit-price" readonly></div>
      <div><label>ราคารวม (ก่อน Mark-up):</label><input type="text" id="total-price" readonly></div>
    </div>
    
    <!-- Mark-up section hidden by default, for UI only (affects preview/print output) -->
    <div id="markup-section" style="margin-top:8px" class="info-grid">
      <div>
        <label>Mark-up (%):</label>
        <input type="number" id="markup-rate" value="30" min="0" max="100" step="0.1" onchange="updateSummary()" oninput="updateSummary()">
      </div>
      <div><label>จำนวนค่า Mark-up:</label><input type="text" id="markup-amount" readonly></div>
      <div><label>ราคารวม (รวม Mark-up):</label><input type="text" id="total-price-with-markup" readonly></div>
    </div>
  
  <div class="section">
  <button onclick="saveData()">บันทึกข้อมูล</button>
  <button onclick="clearSavedData()">ล้างข้อมูลที่บันทึก</button>
  <button onclick="saveAsPDF()">บันทึกเป็น PDF (สำหรับพิมพ์)</button>

    <div id="saved-entries" style="margin-top:12px;border-top:1px solid #eee;padding-top:12px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>รายการที่บันทึก</strong>
        <button type="button" onclick="renderSavedList()">รีเฟรช</button>
      </div>
      <div id="saved-list" style="margin-top:10px;font-size:13px;color:#333">
      </div>
    </div>

    <div id="saved-output" style="background-color:#fff; padding:16px; margin-top:10px; border:1px solid #ddd;"></div>
  </div>

  <script>
  // REPLACE unsafe direct references/logs with guarded versions.
  if (typeof window !== 'undefined' && typeof window.powerDatabase !== 'undefined') {
    console.log('powerDatabase (initial):', window.powerDatabase);
  } else {
    console.log('powerDatabase not loaded yet — waiting for db-scripts-loaded event');
  }
  if (typeof window !== 'undefined' && typeof window.controlDatabase !== 'undefined') {
    console.log('controlDatabase (initial):', window.controlDatabase);
  } else {
    console.log('controlDatabase not loaded yet — waiting for db-scripts-loaded event');
  }

  // keep a helper that runs functions once DB is present
  function onDbReady(fn) {
    if (typeof window !== 'undefined' && typeof window.powerDatabase !== 'undefined' && typeof window.controlDatabase !== 'undefined') {
      try { fn(); } catch(e){ console.warn('onDbReady handler failed', e); }
    } else {
      document.addEventListener('db-scripts-loaded', () => {
        try { fn(); } catch(e){ console.warn('onDbReady handler failed', e); }
      }, { once: true });
    }
  }

  // re-run init actions that depend on DB
  onDbReady(function(){
    try {
      // refresh local aliases to the actual objects (some browsers may use separate script scopes)
      try { powerDatabase = window.powerDatabase; } catch(e){}
      try { controlDatabase = window.controlDatabase; } catch(e){}

      if (typeof updateSummary === 'function') updateSummary();
      if (typeof renderSavedList === 'function') renderSavedList();
    } catch(e){ console.warn('post-db init failed', e); }
  });

  // fillDescriptionFromNo: ALWAYS use window.* guarded access
  function fillDescriptionFromNo(input) {
    const row = input.closest("tr");
    const no = parseInt(input.value);
    const tbody = row.closest("tbody");
    const tableId = tbody ? tbody.id : '';
    let item = null;

    if (tableId.includes("power")) {
      item = (typeof window !== 'undefined' && typeof window.powerDatabase !== 'undefined') ? window.powerDatabase[no] : null;
    } else if (tableId.includes("control")) {
      item = (typeof window !== 'undefined' && typeof window.controlDatabase !== 'undefined') ? window.controlDatabase[no] : null;
    }

    if (item) {
      try { row.cells[3].children[0].value = item.desc; } catch (e) {}
      try { row.cells[2].children[0].value = item.price; } catch (e) {}
    } else {
      try { row.cells[3].children[0].value = ""; } catch (e) {}
      try { row.cells[2].children[0].value = ""; } catch (e) {}
    }
    try { updateTotal(tableId.includes("power") ? "power" : "control"); } catch (e) {}
  }
</script>

  <script>
    // replace: ใช้เวอร์ชันฟังก์ชันที่ถูกใช้งานจริง (จากบล็อกสคริปต์ชุดหลัง)
    function fillDescriptionFromNo(input) {
      const row = input.closest("tr");
      const no = parseInt(input.value) || 0;
      const tbody = row.closest("tbody");
      const tableId = tbody ? tbody.id : '';
      let item = null;

      if (tableId.includes("power")) {
        item = (typeof window !== 'undefined' && typeof window.powerDatabase !== 'undefined') ? window.powerDatabase[no] : null;
      } else if (tableId.includes("control")) {
        item = (typeof window !== 'undefined' && typeof window.controlDatabase !== 'undefined') ? window.controlDatabase[no] : null;
      }

      if (item) {
        // cells: 0=No,1=Qty,2=Price,3=Desc,4=Total,5=Delete
        row.cells[3].children[0].value = item.desc;
        row.cells[2].children[0].value = item.price;
      } else {
        row.cells[3].children[0].value = "";
        row.cells[2].children[0].value = "";
      }
      updateTotal(tableId.includes("power") ? "power" : "control");
    }
  </script>
    <!-- เพิ่มฟังก์ชันตารางเป็น Global สำหรับปุ่ม onclick -->
  <script>
    // ใช้ฟังก์ชันนี้กับ keydown เพื่อ Enter = เพิ่มแถว/ย้ายลง
    function onRowInputKeydown(e) {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      const row = e.target.closest('tr');
      const tbody = row && row.closest('tbody');
      if (!tbody) return;
      const type = tbody.id.includes('power') ? 'power' : 'control';
      const isLast = row.nextElementSibling === null;

      if (isLast) {
        window.addRow(type);
        // โฟกัสไปยังแถวใหม่
        setTimeout(() => {
          const rows = tbody.querySelectorAll('tr');
          const newRow = rows[rows.length - 1];
          if (newRow) {
            const firstInput = newRow.querySelector('input');
            if (firstInput) { firstInput.focus(); firstInput.select && firstInput.select(); }
          }
        }, 0);
      } else {
        // move focus to same column in next row (fall back to first input)
        const nextRow = row.nextElementSibling;
        const colIndex = Array.from(row.cells).indexOf(e.target.closest('td'));
        let targetInput = null;
        if (nextRow && nextRow.cells[colIndex]) {
          targetInput = nextRow.cells[colIndex].querySelector('input');
        }
        if (!targetInput) targetInput = nextRow.querySelector('input');
        if (targetInput) {
          targetInput.focus();
          targetInput.select && targetInput.select();
        }
      }
    }

    // เพิ่มแถว (expose global)
    window.addRow = function addRow(type, item = { no: '', qty: '', price: '', desc: '' }) {
      const tableBody = document.getElementById(`${type}-table-body`);
      if (!tableBody) return;
      const row = document.createElement('tr');
      row.innerHTML = `
        <td><input name="${type}-no[]" type="number" value="${item.no}" onchange="fillDescriptionFromNo(this)" oninput="fillDescriptionFromNo(this)"></td>
        <td><input name="${type}-qty[]" type="number" value="${item.qty}" min="0" onchange="updateTotal('${type}')" oninput="updateTotal('${type}')"></td>
        <td><input name="${type}-price[]" type="number" value="${item.price}" min="0" step="0.01" onchange="updateTotal('${type}')" oninput="updateTotal('${type}')"></td>
        <td><input name="${type}-desc[]" type="text" value="${item.desc}" onchange="updateTotal('${type}')" oninput="updateTotal('${type}')"></td>
        <td><input name="${type}-total[]" type="text" value="0.00" readonly style="background:#f2f2f2; text-align:right;"></td>
        <td><button type="button" onclick="removeRow(this, '${type}')">ลบ</button></td>
      `;
      // ผูก Enter ให้ input ทุกช่องในแถว
      row.querySelectorAll('input').forEach(inp => inp.addEventListener('keydown', onRowInputKeydown));
      tableBody.appendChild(row);
      window.updateTotal(type);
    };

    // ลบแถว (expose global)
        window.removeRow = function removeRow(button, type) {
          const row = button && button.closest && button.closest('tr');
          if (!row) return;
          row.remove();
          // recalc totals
          try { updateTotal(type); } catch(e) { console.warn('updateTotal missing', e); }
        }
    
        function updateTotal(type) {
      const rows = document.querySelectorAll(`#${type}-table-body tr`);
      let sectionTotal = 0;
      rows.forEach(row => {
        const qty = parseFloat(row.cells[1].children[0].value) || 0;
        const price = parseFloat(row.cells[2].children[0].value) || 0;
        const rowTotal = qty * price;
        // update per-row Total display
        const totalInput = row.cells[4].children[0];
        totalInput.value = rowTotal.toFixed(2);
        sectionTotal += rowTotal;
      });
      document.getElementById(`${type}-price`).textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} Price: ` + sectionTotal.toFixed(2) + " Baht";
      updateSummary();
    }

    function getTableSumFromTotals(tableBodyId) {
      const rows = document.querySelectorAll(`#${tableBodyId} tr`);
      let sum = 0;
      rows.forEach(row => {
        const totalInput = row.cells[4] && row.cells[4].children[0];
        if (totalInput) sum += parseFloat(totalInput.value) || 0;
      });
      return sum;
    }

function updateSummary() {
  const powerTotal = getTableSumFromTotals("power-table-body");
  const controlTotal = getTableSumFromTotals("control-table-body");
  const combined = powerTotal + controlTotal;
  const totalSet = parseFloat(document.getElementById("total-set").value) || 1;

  // ราคาต่อชุด (unit price) = combined
  document.getElementById("unit-price").value = combined.toFixed(2);

  // ราคารวมก่อน mark-up = combined * sets
  const subtotal = combined * totalSet;
  document.getElementById("total-price").value = subtotal.toFixed(2);

  // อ่านเปอร์เซ็นต์จาก input (UI-only) และคำนวณ
  const rateInput = document.getElementById("markup-rate");
  const rate = (rateInput && !isNaN(parseFloat(rateInput.value))) ? (parseFloat(rateInput.value) / 100) : 0;
  const markupAmount = subtotal * rate;
  const totalWithMarkup = subtotal + markupAmount;

      const markupAmtEl = document.getElementById('markup-amount');
      const totalWithMarkupEl = document.getElementById('total-price-with-markup');
      if (markupAmtEl) markupAmtEl.value = markupAmount.toFixed(2);
      if (totalWithMarkupEl) totalWithMarkupEl.value = totalWithMarkup.toFixed(2);
    };

    // เพิ่มแถวเริ่มต้น 1 แถวให้แต่ละตาราง หากยังว่าง
    document.addEventListener('DOMContentLoaded', () => {
      try {
        const pb = document.getElementById('power-table-body');
        const cb = document.getElementById('control-table-body');
        if (pb && pb.children.length === 0) window.addRow('power');
        if (cb && cb.children.length === 0) window.addRow('control');
      } catch (e) { console.warn('init rows failed', e); }
    });
  </script>

  <script>
    function getInputValue(id) {
      const el = document.getElementById(id);
      return el ? (el.value || '') : '';
    }

    function collectTableItems(tbodyId) {
      return Array.from(document.querySelectorAll(`#${tbodyId} tr`)).map(row => {
        const grab = (idx) => {
          const cell = row.cells && row.cells[idx];
          if (!cell) return '';
          const input = cell.querySelector('input, textarea');
          return input ? (input.value || '') : '';
        };
        const item = {
          no: grab(0).trim(),
          qty: grab(1).trim(),
          price: grab(2).trim(),
          desc: grab(3).trim(),
          total: grab(4).trim()
        };
        return item;
      }).filter(item => item.no || item.qty || item.price || item.desc || item.total);
    }
    function collectCurrentEntry() {
      try { updateTotal('power'); updateTotal('control'); updateSummary(); } catch (e) {}
      const now = new Date();
      const entry = {
        subName: getInputValue('subName').trim(),
        wa: getInputValue('wa').trim(),
        project: getInputValue('project').trim(),
        cubicle: getInputValue('cubicle').trim(),
        serial: getInputValue('serial').trim(),
        totalSet: parseFloat(getInputValue('total-set')) || 1,
        unitPrice: getInputValue('unit-price') || '0.00',
        totalPrice: getInputValue('total-price') || '0.00',
        markupRate: getInputValue('markup-rate') || '0',
        markupAmount: getInputValue('markup-amount') || '0.00',
        totalPriceWithMarkup: getInputValue('total-price-with-markup') || getInputValue('total-price') || '0.00',
        power: collectTableItems('power-table-body'),
        control: collectTableItems('control-table-body'),
        timestamp: now.getTime(),
        dateOnly: now.toLocaleDateString('th-TH'),
        timeOnly: now.toLocaleTimeString('th-TH', { hour: '2-digit', minute: '2-digit' })
      };
      if (typeof getCurrentUsername === 'function') {
        entry.savedBy = getCurrentUsername();
      }
      return entry;
    }
    window.saveData = function saveData() {
      if (typeof window.saveToLocalStorage !== 'function') {
        console.error('saveToLocalStorage is not available');
        return;
      }
      const entry = collectCurrentEntry();
      if (!entry.power.length && !entry.control.length) {
        alert('กรุณากรอกข้อมูลรายการก่อนบันทึก');
        return;
      }
      if (!window.saveToLocalStorage(entry)) {
        alert('ไม่สามารถบันทึกข้อมูลได้');
        return;
      }
      if (typeof window.renderSavedPreview === 'function') {
        window.renderSavedPreview(entry);
      }
      if (typeof window.renderSavedList === 'function') {
        window.renderSavedList();
      }
      alert('บันทึกข้อมูลเรียบร้อยแล้ว');
    };

    window.clearSavedData = function clearSavedData() {
      if (!confirm('ต้องการล้างข้อมูลที่บันทึกทั้งหมดหรือไม่?')) return;
      if (typeof window.clearSavedListForCurrentUser !== 'function') {
        console.error('clearSavedListForCurrentUser is not available');
        return;
      }
      if (window.clearSavedListForCurrentUser()) {
        const out = document.getElementById('saved-output');
        if (out) out.innerHTML = '';
        if (typeof window.renderSavedList === 'function') {
          window.renderSavedList();
        }
        alert('ล้างข้อมูลเรียบร้อยแล้ว');
      }
    };
    
    // REPLACE saveAsPDF implementation with a clean, syntactically-correct exporter
    window.saveAsPDF = async function saveAsPDF() {
	try {
		const entry = collectCurrentEntry();
		if (!entry) return;
		if (typeof window.renderSavedPreview === 'function') window.renderSavedPreview(entry);

		const savedOutput = document.getElementById('saved-output');
		const pdfPage = savedOutput ? savedOutput.querySelector('.pdf-page') : null;
		if (!pdfPage) {
			alert('ไม่พบเนื้อหาสำหรับสร้าง PDF');
			return;
		}
		if (typeof html2canvas !== 'function') {
			alert('html2canvas not loaded. กรุณารีเฟรชหน้าแล้วลองใหม่');
			return;
		}

		const filenameBase = (entry.ค่าแรงSUB || 'SUB-Estimate').replace(/[\\/:*?"<>|]+/g, '_');
		const filename = `${filenameBase}-${entry.wa || 'output'}.pdf`;

		// existing preview styles
		const previewStyles = Array.from(savedOutput.querySelectorAll('style'));
		let injectedStyle = null;
		if (previewStyles.length) {
			injectedStyle = document.createElement('style');
			injectedStyle.id = 'pdf-export-style';
			injectedStyle.textContent = previewStyles.map(s => s.textContent || '').join('\n');
			document.head.appendChild(injectedStyle);
		}

		// offscreen wrapper
		const exportWrapper = document.createElement('div');
		exportWrapper.id = 'pdf-export-wrapper';
		exportWrapper.style.position = 'fixed';
		exportWrapper.style.left = '-9999px';
		exportWrapper.style.top = '0';
		exportWrapper.style.zIndex = '2147483647';
		exportWrapper.style.background = '#fff';
		exportWrapper.style.boxSizing = 'border-box';
		exportWrapper.style.pointerEvents = 'none';
		exportWrapper.style.padding = '0';
		exportWrapper.style.margin = '0';
		exportWrapper.style.visibility = 'visible';

		// A4 landscape base size (mm)
		const pageWidthMm = 297;
		const pageHeightMm = 210;

		// --- NEW: extra capture area in mm (ปรับค่าได้) ---
		// ตัวอย่าง: ขยายซ้าย/ขวา 10mm เพื่อให้จับพื้นที่เกินขอบ A4
		const extra = { left: 10, right: 10, top: 0, bottom: 0 }; // <-- เปลี่ยนค่าตามต้องการ
		// capture area (mm)
		const captureWidthMm = pageWidthMm + (extra.left || 0) + (extra.right || 0);
		const captureHeightMm = pageHeightMm + (extra.top || 0) + (extra.bottom || 0);
		const mmToPx = 96 / 25.4;
		const captureWidthPx = Math.round(captureWidthMm * mmToPx);

		// clone the pdf page
		const exportNode = pdfPage.cloneNode(true);
		try {
			exportNode.style.setProperty('box-sizing', 'border-box', 'important');
			// keep original content width as pageWidthMm, but we will place it inside a larger capture wrapper
			exportNode.style.setProperty('width', pageWidthMm + 'mm', 'important');
			exportNode.style.setProperty('padding', '0mm', 'important');
			exportNode.style.setProperty('margin', '0', 'important');
			exportNode.style.setProperty('background', '#fff', 'important');
			exportNode.style.setProperty('display', 'block', 'important');
			// move content inward by extra.left so capture includes left bleed
			exportNode.style.setProperty('margin-left', (extra.left || 0) + 'mm', 'important');
		} catch (e) {
			// ignore
		}

		// create capture wrapper sized to captureWidthMm and put exportNode inside
		const captureWrapper = document.createElement('div');
		captureWrapper.id = 'pdf-capture-wrapper';
		captureWrapper.style.boxSizing = 'border-box';
		captureWrapper.style.width = captureWidthMm + 'mm';
		captureWrapper.style.height = 'auto';
		captureWrapper.style.background = '#fff';
		captureWrapper.style.display = 'block';
		captureWrapper.style.padding = '0';
		captureWrapper.style.margin = '0';
		// append exportNode inside captureWrapper
		captureWrapper.appendChild(exportNode);
		exportWrapper.appendChild(captureWrapper);
		document.body.appendChild(exportWrapper);

		// optional: inject export-only override (thin borders) inside the cloned node so preview CSS unaffected
		let injectedOverride = null;
        try {
            injectedOverride = document.createElement('style');
            injectedOverride.id = 'pdf-export-override';
            injectedOverride.textContent = `
                /* compact export: smaller base font, tighter line-height and paddings */
                .pdf-page { padding: 4mm 3mm !important; font-size: 11px !important; line-height: 1.05 !important; -webkit-font-smoothing: antialiased !important; text-rendering: optimizeLegibility !important; }
                .pdf-page h2 { font-size: 16px !important; margin:2px 0 5px !important; }
                .pdf-page h3 { font-size: 12px !important; margin:4px 0 3px !important; }
                .pdf-items th, .pdf-items td {
                  border: 0.08mm solid #444 !important; /* <- reduce thickness for exported PDF */
                }
                .pdf-page .sig-table td {
                  border: 0.08mm solid #444 !important; /* <- keep signature boxes consistent */
                }
                .pdf-page.pdf-nowrap th, .pdf-page.pdf-nowrap td {
                  border: 0.08mm solid #444 !important; /* <- override nowrap-case as well */
                }
                table { border-collapse: collapse !important; }
                /* ensure high contrast */
                .pdf-page, .pdf-page * { color: #111 !important; }
            `;
            captureWrapper.insertBefore(injectedOverride, captureWrapper.firstChild);
        } catch (e) { injectedOverride = null; }

// Force single-line mode on the cloned page and enforce per-cell styles as a fallback
try {
  exportNode.classList.add('pdf-nowrap');
  exportNode.querySelectorAll('th, td').forEach(cell => {
    try {
      cell.style.setProperty('white-space', 'nowrap', 'important');
      cell.style.setProperty('overflow', 'visible', 'important');
      cell.style.setProperty('text-overflow', 'clip', 'important');
    } catch (e) {}
  });
} catch (e) { /* ignore */ }

        const cleanup = () => {
            try { if (exportWrapper.parentNode) exportWrapper.parentNode.removeChild(exportWrapper); } catch (e) {}
            try { if (injectedStyle && injectedStyle.parentNode) injectedStyle.parentNode.removeChild(injectedStyle); } catch (e) {}
            try { if (injectedOverride && injectedOverride.parentNode) injectedOverride.parentNode.removeChild(injectedOverride); } catch (e) {}
        };

		// allow styles to apply
		await new Promise(r => setTimeout(r, 160));

		// capture with sufficient scale
		const deviceScale = window.devicePixelRatio || 1;
		// higher scale for crisper text/lines; limit to avoid huge memory usage
		const scale = Math.min(4, Math.max(3, Math.round(deviceScale * 2)));
		const canvas = await html2canvas(captureWrapper, { scale, useCORS: true, allowTaint: false, backgroundColor: '#ffffff', logging: false });
		// use PNG (lossless) to preserve line clarity
		const imgData = canvas.toDataURL('image/png');

		// compute mm sizes from captured canvas (canvas.width corresponds to captureWidthMm)
		const pxPerMmActual = canvas.width / captureWidthMm;
		const captureWmmFromCanvas = canvas.width / pxPerMmActual; // ~ captureWidthMm
		const captureHmmFromCanvas = canvas.height / pxPerMmActual;

		// ensure jsPDF class available (UMD bundle exposes window.jspdf.jsPDF or window.jsPDF)
		const jsPDFClass = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jsPDF || null);
		if (!jsPDFClass) {
			// fallback to html2pdf if available
			if (window.html2pdf && typeof window.html2pdf === 'function') {
				await window.html2pdf().from(captureWrapper).set({ filename }).save();
				cleanup();
				return;
			}
			throw new Error('jsPDF not available');
		}

		// Create standard A4 landscape PDF and scale the captured image to fit A4
		const pdf = new jsPDFClass({ orientation: 'landscape', unit: 'mm', format: 'a4' });
		const pdfW = pdf.internal.pageSize.getWidth();
		const pdfH = pdf.internal.pageSize.getHeight();

		// Use zero margins to allow maximum fill of A4; change if small white gutter desired
		const marginLeft = 0;
		const marginRight = 0;
		const marginTopBottom = 0;
		const usableW = pdfW - marginLeft - marginRight;
		const usableH = pdfH - marginTopBottom * 2;

		// content size in mm (capture area)
		const contentWmm = captureWidthMm;
		const contentHmm = captureHeightMm;

		// scale to fit A4 (preserve aspect ratio)
		const fitScale = Math.min(usableW / contentWmm, usableH / contentHmm);
		const drawW = contentWmm * fitScale;
		const drawH = contentHmm * fitScale;

		// center on page
		const x = marginLeft + Math.max(0, (usableW - drawW) / 2);
		const y = marginTopBottom + Math.max(0, (usableH - drawH) / 2);

		pdf.addImage(imgData, 'JPEG', x, y, drawW, drawH);
		pdf.save(filename);

		cleanup();
	} catch (err) {
		console.error('saveAsPDF failed', err);
		alert('การสร้างไฟล์ PDF ล้มเหลว (ดูคอนโซลสำหรับรายละเอียด)');
	}
};

  </script>
 </body>
 </html>
